# [3장] 리액트 훅 깊게 살펴보기

## 3.1 리액트의 모든 훅 파헤치기

### 3.1.1 `useState`
---
**기본 형태**

- 인수는 `state`의 초기값
- 반환 값은 배열이며, 첫 번째 원소로 `state` 값 자체를 사용할 수 있고, 두 번째 원소인 `setState` 함수를 사용해 해당 `state` 값 변경 가능

**`useState`는 어떻게 함수가 실행돼도 그 값을 유지할 수 있을까?**

- 함수 컴포넌트는 렌더링이 될 때마다 다시 새롭게 실행되고, 그 과정에서 함수 내부의 값은 항상 초기화됨
- `useState`는 값을 유지하기 위해 **클로저**를 사용했다!
- 어떤 함수(`useState`) 내부에 선언된 함수(`setState`)가, 함수의 실행이 종료된 이후(`useState`가 호출된 이후)에도 지역 변수인 `state`를 계속 참조할 수 있다는 것

**게으른 초기화**

- `useState`의 인수로 원시값이 아닌 "특정한 값을 넘기는 함수"를 넣는 경우
- `useState`의 초깃값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용
- 게으른 초기화 함수는 오직 `state`가 **처음 만들어질 때만** 사용
- 이후 리렌더링이 발생하면 이 함수의 실행은 무시됨

<br />

### 3.1.2 `useEffect`
---
**기본 형태**

- 2개의 인수를 받는데, 첫 번째는 "콜백", 두 번째는 "의존성 배열"
- 이 두 번째 의존성 배열의 값이 변경되면 첫 번째 인수인 콜백 실행
- 클래스 컴포넌트의 생명주기 메서드와 비슷한 작동 구현 가능
- 클린업 함수를 반환할 수 있는데, 이 클린업 함수는 컴포넌트가 언마운트 될 때만 실행

**정확한 정의**

→ 애플리케이션 내 컴포넌트의 여러 값들을 활용해 **동기적으로 부수 효과**를 만드는 매커니즘

**`useEffect`는 어떻게 의존성 배열이 변경된 것을 아는 걸까?**

- 함수 컴포넌트는 매번 함수를 실행해서 렌더링을 수행
- 렌더링 시마다 고유의 `state`와 `props`를 갖고 있음
- 렌더링할 때마다 의존성에 있는 값을 보면서, **이전과 하나라도 다르면** 부수 효과 실행

**클린업 함수의 목적**

- 보통 이벤트를 등록하고 지울 때 사용
- 이전 `state`를 참조해 실행되는데, 함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행
- 함수 컴포넌트의 `useEffect`는 콜백이 실행될 때마다 **이전의 클린업 함수가 존재한다면 그 클린업 함수를 실행한 뒤에 콜백 실행**
- 생명주기 메서드의 언마운트와는 차이가 있기 때문에 주의해서 사용하자

**의존성 배열**

1. 빈 배열 : 최초 렌더링 직후에 실행된 다음부터는 더 이상 실행 X
2. 아무런 값도 넘겨주지 않음 : 렌더링 발생할 때마다 실행
3. 사용자가 직접 원하는 값을 넣음

**사용할 때 주의할 점**

1. `eslint-disable-line, react-hooks/exhaustive-deps` 주석은 최대한 자제하자
2. 첫 번째 인수에 함수명을 부여하자
3. 거대한 `useEffect`를 만들지 말자
4. 불필요한 외부 함수를 만들지 말자

**콜백 인수로 비동기 함수를 바로 넣을 수 없는 이유**

- 비동기 함수의 응답 속도에 따라 결과가 의도하지 않은대로 나타날 수 있음 (race condition)
- 내부에서 비동기 함수 선언해서 실행하거나 즉시실행 비동기 함수를 만들어서 사용하자

<br />

### 3.1.3 `useMemo`
---
**기본 형태**

- 비용이 큰 연산에 대한 결과를 저장해두고, 이 저장된 값을 반환하는 훅
- 첫 번째 인수 : 어떠한 값을 반환하는 생성 함수
- 두 번째 인수 : 해당 함수가 의존하는 값의 배열
- 렌더링 발생 시,
  - 의존성 배열의 값이 변경되지 않았다면, 함수를 재실행하지 않고 이전에 기억해 둔 값 반환
  - 의존성 배열의 값이 변경되었다면, 첫 번째 인수의 함수를 실행한 후에 값을 반환하고 다시 기억
- 값뿐만 아니라 '컴포넌트'를 메모이제이션 하는 것도 가능

<br />

### 3.1.4 `useCallback`
---
**기본 형태**

- 인수로 넘겨받은 콜백 자체를 기억
- 첫 번째 인수로 '함수', 두 번째 인수로 '의존성 배열'을 넣는다
- 의존성 배열이 변경되지 않는 한 함수를 재생성 하지 않음

**`useMemo`와의 차이**

- 단순히 메모이제이션 하는 대상이 '변수'냐 '함수'냐의 차이
- 동일한 역할을 한다!

<br />

### 3.1.5 `useRef`
---
**기본 형태**

- `useState`와 비슷
- 컴포넌트 내부에서 렌더링이 일어나도 변경 가능한 상태값을 저장하는 것은 동일
- `current`로 값에 접근 또는 변경이 가능하고, **값이 변하더라도 렌더링을 일으키지 않는다**는 게 주된 차이점

<br />

### 3.1.6 `useContext`
---
**Context**

- props drilling 을 극복하기 위해 등장한 개념

**`useContext`**

- 상위 컴포넌트에서 만들어진 Context를 함수 컴포넌트에서 사용할 수 있도록 만들어진 훅
- `Context.Provider`에서 제공한 값 사용 가능
- 여러 개의 `Provider`가 있으면, **가장 가까운 `Provider`에서** 값을 가져옴

**사용할 때 주의할 점**

1. 함수 컴포넌트 내부에서 사용할 때는, 재활용이 어려워진다
2. 상태 관리를 위한 리액트 API로 오해하지 말자

<br />

### 3.1.7 `useReducer`
---
**기본 형태**

- 반환 값 : 길이가 2인 배열
  - `state` : 현재 `useReducer`가 가지고 있는 값
  - `dispatcher` : `state`를 업데이트 하는 함수
 
- 인수 3개
  - `reducer` : `useReducer`의 기본 `action`을 정의하는 함수
  - `initialState` : `useReducer`의 초깃값
  - `init` : 초깃값을 지연해서 생성하고 싶을 때 사용하는 함수(필수 X)

<br />
 
### 3.1.8 `useImperativeHandle`
---
**forwardRef**

- 상위 컴포넌트에서 하위 컴포넌트로 `ref`를 전달하고 싶을 때 명시적으로 사용

**`useImperativeHandle`**

- 부모에게서 넘겨받은 `ref`를 원하는대로 수정할 수 있는 훅

<br />

### 3.1.9 `useLayoutEffect`
---
**기본 형태**

- 시그니처는 `useEffect`와 동일하나, **모든 DOM의 변경 후에 동기적으로 발생**
- 항상 `useEffect`보다는 먼저 실행된다!
- DOM은 계산됐지만, 이것이 화면에 반영되기 전에 하고 싶은 작업이 있을 때 사용

<br />

### 3.1.10 `useDebugValue`
---
**기본 형태**

- 디버깅할 때 사용하는 훅
- 사용자 정의 훅 내부의 내용에 대한 정보를 남길 수 있는 훅

<br />

### 3.1.11 훅의 규칙
---
**`rules-of-hooks`**

1. 최상위에서만 훅을 호출해야 한다
2. 훅을 호출할 수 있는 것은 `리액트 함수 컴포넌트`, `사용자 정의 훅` 이렇게 2가지 뿐

**훅의 순서**

- 리액트 훅은 **파이버 객체의 링크드 리스트 호출 순서에 따라 저장**됨
- 이전 값과의 비교 등을 위해 순서를 보장해야 한다!!

<br />

## 3.2 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?

### 3.2.1 사용자 정의 훅
---
**기본 형태**

- 서로 다른 컴포넌트 내부에서 같은 로직을 공유하고자 할 때 주로 사용
- 리액트에서만 사용 가능
- 이름이 반드시 `use`로 시작해야 함

<br />

### 3.2.2 고차 컴포넌트
---
**기본 형태**

- 컴포넌트 자체의 로직을 재사용
- 고차 함수의 일종으로, 꼭 리액트가 아니더라도 JavaScript 환경이면 사용 가능

**`React.memo`**

- 대표적인 리액트의 고차 컴포넌트
- 렌더링하기 전에 `props`를 비교해서 이전과 같다면 렌더링 자체를 생략하고, 이전에 메모이제이션 해 둔 컴포넌트 반환

**사용할 때 주의할 점**

- 이름이 `with`로 시작해야 함(필수는 아니지만 관행이다)
- 부수효과를 최소화 하자

<br />

### 3.2.3 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?
---
**사용자 정의 훅이 필요한 경우**

- 리액트에서 제공하는 훅으로만 공통 로직을 격리할 수 있는 경우

**고차 컴포넌트를 사용해야 하는 경우**

- 렌더링 결과물에도 영향을 미치는 공통 로직일 경우
