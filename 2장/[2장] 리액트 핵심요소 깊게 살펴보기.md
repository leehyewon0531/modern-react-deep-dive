# [2장] 리액트 핵심요소 깊게 살펴보기

**2.1 JSX란?**

- XML과 유사한 내장형 구문
- 리액트에 종속적이지 않은 독자적인 문법
- 자바스크립트 엔진이나 브라우저에 의해서 실행되거나 표현되도록 만들어진 구문이 아니기 때문에 트랜스파일을 거쳐야함

**2.1.1 JSX의 정의**

JSX는 기본적으로 JSXElement, JSXAttributes, JSXChildren, JSXStrings 4가지 컴포넌트를 기반으로 구성됨

**`JSXElement`**

- JSX를 구성하는 가장 기본 요소로, HTML의 요소(element)와 비슷한 역할을 한다. JSXElement가 되기 위해서는 다음과 같은 형태 중 하나여야 한다.
    - JSXOpeningElement
    - JSXClosingElement
    - JSXSelfClosingElement
    - JSXFragment

**`JSXElementName`**

- JSXElement의 요소 이름으로 쓸 수 있는 것
    - JSXIdentifier
    - JSXNamespacedName
    - JSXMemberExpression

**`JSXAttributes`**

JSXElement에 부여할 수 있는 속성을 의미한다. 모든 경우에서 필수값이 아니고, 존재하지 않아도 된다

- JSXSpreadAttributes: JS의 전개 연산자와 동일한 역할을 한다
- JSXAttribute: 속성을 나타내는 키(JSXAttributeName)와 값(JSXAttributeValue)으로 짝을 이루어서 표현하다

**`JSXChildren`**

- JSXElement의 자식 값을 나타낸다.
- JSXChild: JSXChildren을 이루는 기본 단위로, JSXChildren은 JSXChild을 0개 이상 가질 수 있다.
    - JSXText
    - JSXElement
    - JSXFragment
    - {JSXChildExpression (optional)}

**`JSXStrings`**

HTML에서 사용 가능한 문자열은 모두 JSXStrings에서도 가능하다. 이는 개발자가 HTML의 내용을 손쉽게 JSX로 가져올 수 있도록 의도적으로 설계된 부분이다.

**2.1.2 JSX 예제**

**2.1.3 JSX는 어떻게 자바스크립트에서 변환될까?**

JSX 코드를 `@babel/plugin-transform-react-jsx`로 변환한 결과

```tsx
// JSX 코드
const ComponentA = <A required={true}>Hello World</A>;

// 트랜스파일한 결과
var ComponentA = React.createElement(A, { required: true }, "Hello World");
```

- `JSXElement`를 첫 번째 인수로 선언해 요소를 정의한다.
- 옵셔널인 JSXChildren, JSXAttributes, JSXStrings는 이후 인수로 넘겨주어 처리한다.
- JSX 반환값이 결국 React.createElement로 귀결된다는 사실을 파악한다면 코드 중복을 최소화할 수 있다.

**2.2 가상 DOM과 리액트 파이버**

**2.2.1 DOM과 브라우저 렌더링 과정**

1. HTML파일을 다운로드
2. HTML 파싱 -> DOM노드로 구성된 트리(DOM) 생성
3. 2번 과정에서 CSS파일을 만나면 CSS파일 다운로드
4. CSS 파싱 -> CSS 노드로 구성된 트리(CSSOM)를 생성
5. 2번 과정에서 만든 DOM 노드를 순회, 사용자 눈에 보이는 노드만 방문 한다.(ex. display: none과 같이 화면에 보이지 않는 요소는 방문x) 이는 트리를 분석하는 과정을 조금이라도 빠르게 하기 위해서다
6. 눈에 보이는 노드를 대상으로 CSSOM 정보를 찾고 스타일을 적용한다. 이 DOM 노드에 CSS를 적용하는 과정은 크게 두 가지로 나뉜다.
    - 레이아웃: 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정. 이 레이아웃 과정을 거치면 반드시 페인팅 과정도 거치게 된다.
    - 페인팅: 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정

**2.2.2 가상 DOM의 탄생 배경**

- 렌더링 이후에 정보를 사용자 인터랙션에 따라 동적으로 웹페이지가 변경될 수 있어야 한다.
- 렌더링이 완료된 이후에도 사용자의 인터렉션에 의한 변경을 고려해야 한다.

**2.2.3 가상 DOM을 위한 아키텍처, 리액트 파이버**

**리액트 파이버란?**

- 리액트에서 관리하는 평범한 자바스크립트 객체
- 파이버 재조정자(reconciler)가 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하며, 변경이 필요한 경우 해당 파이버를 기준으로 화면에 렌더링을 요청한다.
- 리액트 파이버의 목표는 리액트의 웹 애플리케이션에서 발생하는 애니메이셔느 레이아우스 사용자 인터렉션에 올바른 결과물을 만드는 반응성 문제를 해결하는 것이다. 이를 위해 파이버는 다음과 같은 일을 할 수 있다.
    - 작업을 작은 단위로 분할하고 쪼갠 다음. 우선순위를 매긴다.
    - 이러한 작업은 일시 중지하고 나중에 다시 시작할 수 있다.
    - 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기할 수 있다.

이러한 작업은 비동기로 이루어진다.

과거의 리액트의 조정 알고리즘은 스택 알고리즘을 사용하여 동작했었다. 하나의 스택에 렌더링에 필요한 작업들이 쌓이면 이 스택이 완료될 때까지 동기적으로 작업이 이루어졌다. 그러나 자바스크립트의 싱글 스레드 특성으로 인해 이 동기 작업은 중단될 수 없었고, 이로 인해 리액트의 효율성이 저하됐었다.

사용자 인터랙션과 애니메이션애 대응하려면 다양한 작업을 처리해야 한다. 리액트 파이버는 이러한 비효율성을 없애기 위해 도입되었으며, 작업을 작은 단위로 분할하고 우선순위를 매겨 비동기적으로 처리함으로써 성능을 향상시킨다.

**2.2.4 파이버와 가상 DOM**

- 파이버는 리액트 컴포넌트에 대한 정보를 1:1로 가지고 있는 리액트의 가성 DOM이다.
- 파이버를 활용하는 리액트는 렌더링 작업을 비동기적으로 수행한다.

실제 브라우저 구조인 DOM에 반영하는 과정은 동기적으로 이루어져야 한다. 그러나 리액트는 최적의 성능을 위해 메모리 상에서 작업을 비동기적으로 수행하고, 변경이 필요한 부분만 최종 결과물로 만들어진 가상 DOM을 실제 브라우저의 DOM에 적용합니다. 이렇게 비동기적으로 작업을 처리하면서도 동기적으로 결과를 반영함으로써 성능 향상과 효율적인 렌더링을 이루어냅니다.

메모리 상에서 먼저 수행해서 최종적인 결과물만 실제 브라우저 DOM에 적용하는 것이다.

**2.3 클래스형 컴포넌트와 함수형 컴포넌트**

**2.3.1 클래스형 컴포넌트**

**클래스형 컴포넌트의 한계**

1. 데이터의 흐름을 추적하기 어렵다
2. 애플리케이션 내부 로직의 재사용이 어렵다
3. 기능이 많아질수록 컴포넌트의 크기가 커진다
4. 클래스는 함수에 비해 상대적으로 어렵다
5. 코드 크기를 최적화하기 어렵다
6. 핫 리로딩에 상대적으로 불리하다

**2.3.2 함수형 컴포넌트**

- render 내부에서 필요한 함수를 선언할 때 this 바인딩을 조심할 필요도 없으며, state는 객체가 아닌 각각의 원시값으로 관리되어 훨씬 사용하기가 편해졌다.
- 렌더링하는 코드인 return 에서도 굳이 this를 사용하지 않더라도 props와 state에 접근할 수 있게 됐다.

**2.3.3 함수형 컴포넌트 vs. 클래스형 컴포넌트**

**생명주기 메서드의 부재**

- 함수형 컴포넌트에서는 생명주기 메서드가 존재하지 않는다. 생명주기 메서드는 React.Component에서 오는 것이기 때문에 클래스형 컴포넌트가 아닌 이상 생명주기 메서드는 사용할 수 없다.

함수형 컴포넌트는 useEffect훅을 사용해서 componentDidMount, componentDidUpdate, componentWillUnmount를 비슷하게 구현할 수 있다. (비슷할 뿐이지 똑같지는 않다, useEffect는 생명주기를 위한 훅이 아니다)

**함수형 컴포넌틔와 렌더링된 값**

함수형 컴포넌트는 렌더링된 값을 고정하고, 클래스형 컴포넌트는 그렇지 못하다.

```tsx
export function FunctionalComponent(props) {
  const showMessage = () => {
    alert("Hello", props.user);
  };

  const handleClick = () => {
    setTimeout(showMessage, 3000);
  };

  return <button onClick={handleClick}>Follow</button>;
}

export class ClassComponent extends React.Component {
  private showMessage = () => {
    alert("Hello", this.props.user);
  };

  private handleClick = () => {
    setTimeout(this.showMessage, 3000);
  };

  public render() {
	<button onClick={this.handleClick}>Follow</button>;
  }
}
```

여기서 FunctionalComponent와 ClassComponent는 같은 작업을 하고있다. 하지만 3초 사이에 props를 변경하면 차이가 있다.

`ClassComponent`의 경우 3초 뒤에 변경된 props를 기준으로 메세지가 뜨고 `FunctionalComponent`은 클릭했던 시점의 props값을 기준으로 메세지가 뜬다.

**이러한 차이가 왜 발생할까?**

클래스형 컴포넌트는 props값을 항상 this로 부터 가져온다. 클래스형 컴포넌트의 props는 외부에서 변경되지 않는 이상 불변 값이지만 this가 가리키는 객체, 즉 컴포넌트의 인스턴스 멤버는 변경가능한 값이다. 따라서 render 메서드를 비롯한 리액트 생명주기 메서드가 변경된 값을 읽을 수 있게 된다.

**2.4 렌더링은 어떻게 일어나는가?**

브라우저에서 렌더링이란 HTML과 CSS 리소스를 기반으로 웹페이지에 필요한 UI를 그리는 과정을 의미하며, 이 과정이 어떻게 이뤄지느냐에 따라 성능에 큰 영향을 미친다.

리액트의 경우 브라우저가 렌더링에 필요한 DOM트리를 만드는 과정을 의미한다.

**2.4.1 리액트의 렌더링이란?**

리액트 애플리케이션 트리 안에 모든 컴포넌트가 현재 자신들이 가지고 있는 props와 state값을 기반으로 어떻게 UI를 구성할지 계산하고, 이를 바탕으로 어떤 DOM 결과를 브라우저에게 제공할지 결정하는 일련의 과정을 의미한다.

**2.4.2 리액트의 렌더링이 일어나는 이유**

리액트에서 렌더링이 발생하는 시나리오를 이해하는 것이 중요하다. 리액트에서 렌더링이 발생하는 이유는 다음과 같다.

**리액트에서 렌더링이 발생하는 시나리오**

**1. 최초 렌더링**

- 사용자가 애플리케이션에 처음 접근하면 리액트는 브라우저에 정보를 제공하기 위해 최초 렌더링을 수행한다

**2. 리렌더링**

- 최초 렌더링 이후에는 다양한 상황에서 리렌더링이 발생한다.
- **클래스형 컴포넌트의 `setState`가 실행되는 경우**
- **클래스형 컴포넌트의 `forceUpdate`가 실행되는 경우**
- **함수형 컴포넌트의 `useState()`의 두 번째 배열 요소의 setter가 실행되는 경우**
- **함수형 컴포넌트의 `useReducer()`의 두 번째 배열 요소인 dispatch가 실행되는 경우**
- **컴포넌트의 key props가 변경되는 경우**
    - 리액트에서 key는 명시적으로 선언돼 있지 않더라도 모든 컴포넌트에서 사용할 수 있는 특수한 props으로, 주로 배열에서 하위 컴포넌트를 선언할 때 사용된다
    - 리액트에서 배열에 key를 쓰지 않으면 콘솔에 경고가 출력된다
        
        ⮑ 리액트에서 key는 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값이다. 리액트 파이버 트리 구조에서는 형제 컴포넌트를 구별하기 위해서 각자 sibling이라는 속성값을 사용했다. 만약 동일한 자식 컴포넌트가 여러 개 있는 구조일 때 리렌더링이 발생 시 current 트리와 workInProgress트리 사이에서 어떠한 컴포넌트가 변경이 있었는지 구별해야 하는데 이때 사용하는 값이 바로 **key**이다.
        
- **props가 변경되는 경우**
    - 부모로부터 전달받은 props값이 변동되면 이를 사용하는 자식컴포넌트에서도 변경이 필요해서 리렌더링이 발생한다
- **부모 컴포넌트가 렌더링될 경우**
    - 부모 컴포넌트라 리렌더링 된다면 자식 컴포넌트도 무조건 리렌더링이 발생한다

이러한 상황에서 리액트는 변경된 내용에 대한 새로운 UI를 계산하고 브라우저에 반영하여 화면을 갱신한다. 렌더링은 애플리케이션 상태의 변화에 따라 발생하며, 성능 최적화를 위해 주의 깊게 고려되어야 한다.

**2.4.3 리액트의 렌더링 프로세스**

리액트에서 렌더링 프로세스는 다음과 같이 진행된다.

1. **렌더링 시작**: 렌더링 프로세스가 시작되면 리액트는 컴포넌트 트리의 루트부터 아래로 내려가면서 업데이트가 필요한 모든 컴포넌트를 찾는다.
2. **렌더링 단계**:
    - 클래스형 컴포넌트의 경우 `render()`함수를 실행하고, 함수형 컴포넌트의 경우 `FunctionComponent()`을 호출한다.
    - **JSX 문법**은 `React.createElement()`로 변환되며, 생성된 React 엘리먼트는 가상 DOM에 저장된다

```tsx
function Hello() {
  return (
    <TestComponent a={35} b="yceffort">
      안녕하세요
    </TestComponent>
  );
}

// 위 JSX 문법은 다음과 같은 React.createElement를 호출해서 변환된다

function Hello() {
  return React.createElement(
    TestComponent,
    { a: 35, b: "yceffort" },
    "안녕하세요"
  );
}
```

createElement()는 브라우저의 UI 구조를 설명할 수 있는 일반적인 자바스크립트 객체를 반환한다

```tsx
{
  type: TestComponent,
  props:{a:35, b:"yceffort", children: "안녕하세요"}
}
```

이러한 작업을 통해 각 컴포넌트의 렌더 결과물이 수집된다.

1. **재조정(Reconciliation)**
- 렌더링 결과물은 실제 DOM에 적용되기 전에 현재의 가상 DOM과 비교된다.
- 변경된 내용을 찾아내고, 실제 DOM에 적용하기 위한 모든 변경 사항을 수집한다.
- 이러한 과정을 재조정이라고 한다.

**2.4.4 렌더와 커밋**

**렌더 단계(Render Phase)**

- 컴포넌트를 렌더링하고 변경 사항을 계산하는 과정
- JSX 문법으로 작성된 컴포넌트를 실행하고, 이전 가상 DOM과 비교하여 변경이 필요한 컴포넌트를 찾는다.
    
    > 이때 비교하는 주요 요소는 크게 세 가지로, type, props, key 이다. 이 중 하나라도 변경된 것이 있으면 해당 컴포넌트는 변경이 필요한 컴포넌트로 체크된다.
    > 

**커밋 단계(Commit Phase)**

- 렌더 단계에서 발생한 변경 사항을 실제 DOM에 적용하여 사용자에게 보여주는 단계.
- 렌더 단계에서 찾은 변경이 필요한 컴포넌트를 실제 DOM에 반영하고, 화면을 갱신한다.

이렌더 단계와 커밋 단계가 나뉘어서 실행되며, 이전 가상 DOM과의 비교를 통해 효율적으로 변경 사항을 감지하고 적용한다

리액트가 먼저 DOM을 커밋 단계에서 업데이트하면 만들어진 모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트 한다. 그 후, 클래스형 컴포넌트의 경우 `componentDidMount`, `componentDidUpdate` 메서드를 호출하고, 함수형 컴포넌트에서는 `useLayoutEffect` 훅을 호출한다

여기서 주목할 점은 `리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 발생하는 것은 아니다`는 점이다. 렌더링을 수행했으나 커밋 단게까지 갈 필요가 없다면, 즉 변경 사항을 계산했는데 아무런 변경 사항이 감지되지 않는다면 이 커밋 단계는 생략될 수 있다. 즉 리액트의 렌더링은 가시적인 변경이 없어도 발생할 수 있다. 렌더링 과정 중 첫 번째 단계인 렌더 단계에서 변경 사항을 감지할 수 없다면 커밋 단계가 생략되어 브라우저의 DOM 업데이트가 일어나지 않을 수 있다.

이 두 가지 과정으로 이뤄진 리액트의 렌더링은 항상 동기식으로 작동했다. 따라서 렌더링 과정이 길어질수록 애플리케이션의 성능 저하로 이어지고, 결과적으로 그 시간만큼 브라우저의 다른 작업을 지연시킬 가능성이 있다.

A라는 상태가 변경되면 B와 C가 각각 B1, C1 이 되어야 하는데, A가 변경됐음에도 하나의 컴포넌트가 뒤늦게 변경되어 B, C1 상태로 남아있다고 가정해보자, 이때 B의 컴포넌트 렌더링 작업이 무거워 상대적으로 빠르게 렌더링할 수 있는 C라도 변경해서 보여줄 수 있다면? 이럴 때 의도된 우선순위로 컴포넌트를 렌더링해 최적화할 수 있는 비동기 렌더링, '동시성 렌더링'이 활용된다.

**2.4.5 일반적인 렌더링 시나리오 살펴보기**

**2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션**

`memo`, `useMemo`, `useCallback`은 최적화 기법에 사용된다

**2.5.1 주장 1: 섣부른 최적화는 독이다, 꼭 필요한 곳에만 메모이제이션을 추가하자**

메모이제이션은 **비용이 드는 작업**이므로 항상 신중해야 한다.

- 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업 비용
- 이전에 결과물을 저장해 두었다가 다시 꺼내와야 하는 비용

메모이제이션 비용이 리렌더링 비용보다 저렴할까?

- > 상황에 따라 다르므로 섣부른 최적화는 항상 경계해야 한다.

**meme를 하지 않았을 때 발생할 수 있는 문제**

**2.5.2 주장 2: 렌더링 과정의 비용은 비싸다, 모조리 메모이제이션해 버리자**

- 렌더링을 함으로써 발생하는 비용
- 컴포넌트 내부의 복잡한 로직의 재실행
- 위 두가지가 모든 자식 컴포넌트에서 반복해서 일어남
- 리액트가 구 트리와 신규 트리를 비교

정리하자면, 메모이제이션은 하지 않는 것보다 메모이제이션했을 때 더 많은 이점을 누릴 수 있다. 섣부른 초기화라 할지라도 했을 때 누릴 수 있는 이점, 그리고 이를 실수로 빠트렸을 때 치러야 할 위험 비용이 더 크기 때문에 최적화에 대한 확신이 없다면 가능한 한 모든 곳에 메모이제이션을 활용한 최적화를 하는 것이 좋다.